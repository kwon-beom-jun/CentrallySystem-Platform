import axios from 'axios';
import router from '@/router';
import { toast } from 'vue3-toastify';
// import { useLoadingStore } from '@/store/loading'; // <- 최상단 import 에러 발생

/**
 *  예시
        import { authApi } from '@/api/apiConfig';

        export const login = (credentials) => {
        return hrmApi.post('/', credentials);
        };
 */

// 같은 내용이 2초 안에 또 오면 무시
const recent = new Set();              // 방금 띄운 메시지를 기억
function pushToastOnce(msg, ttl = 2000) {
  if (recent.has(msg)) return;         // 이미 3초 안에 떠 있었다면 건너뜀

  recent.add(msg);
  setTimeout(() => recent.delete(msg), ttl);   // TTL 지나면 해제

  toast.error(msg, { autoClose: ttl });        // toastId 안 써도 OK
}

// SYSTEM API 인스턴스
const systemApi = axios.create({
  baseURL: import.meta.env.VITE_SYSTEM_API_BASE_URL, // .env 파일에 설정된 RECEIPT API 기본 URL
  withCredentials: true, // 쿠키 전송 허용(HttpOnly 쿠키로 JWT 관리)
  headers: {
    'Content-Type': 'application/json',
  },
});

// AUTH API 인스턴스
const authApi = axios.create({
  baseURL: import.meta.env.VITE_AUTH_API_BASE_URL, // .env 파일에 설정된 AUTH API 기본 URL
  withCredentials: true, // 쿠키 전송 허용
  headers: {
    'Content-Type': 'application/json',
  },
});

// HRM API 인스턴스
const hrmApi = axios.create({
  baseURL: import.meta.env.VITE_HRM_API_BASE_URL, // .env 파일에 설정된 HRM API 기본 URL
  withCredentials: true, // 쿠키 전송 허용
  headers: {
    'Content-Type': 'application/json',
  },
});

// RECEIPT API 인스턴스
const receiptApi = axios.create({
  baseURL: import.meta.env.VITE_RECEIPT_API_BASE_URL, // .env 파일에 설정된 RECEIPT API 기본 URL
  withCredentials: true, // 쿠키 전송 허용(HttpOnly 쿠키로 JWT 관리)
  headers: {
    'Content-Type': 'application/json',
  },
});

// 딜레이 함수 (ms 만큼 대기)
// 대기 (ms) : toast 팝업 표시
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 인터셉터 등록을 지연시키기 위한 함수
//    apiConfig.js에서 useLoadingStore()를 파일 최상단(모듈 스코프)에서 import해서 바로 호출하거나,
//    addAuthInterceptor()를 import 시점에 즉시 실행하면 에러 발생 하므로 분리
//    아직 Pinia가 main.js에서 app.use(createPinia())로 등록되지 않았는데 store를 쓰려고 해서 에러 발생
export function initInterceptors() {

  // 로딩 PINIA
  const { useLoadingStore } = require('@/store/loading'); 
  // 유저 PINIA
  const { useAuthStore } = require('@/store/auth');

  const loadingStore = useLoadingStore();
  const authStore = useAuthStore();

  // 공통으로 사용할 인터셉터 추가
  const addAuthInterceptor = (apiInstance) => {

    // ─────────────────────────────────────────────────────────────
    // (1) Request Interceptor
    // ─────────────────────────────────────────────────────────────
    apiInstance.interceptors.request.use(
      (config) => {
        // 요청이 시작될 때 로딩 카운트를 올림
        loadingStore.startLoading();

        const currentRoute = router.currentRoute.value;
        const menu = currentRoute?.meta?.menu || "";
        // const user = authStore.user;

        // config.headers['X-Menu-Vue'] = encodeURIComponent(menu);
        // config.headers['X-User-Vue'] = encodeURIComponent(user);

        // path=/ 는 쿠키의 유효 경로(path)를 지정
        document.cookie = "X-Menu-Vue=" + encodeURIComponent(menu) + "; path=/";

        // HttpOnly 쿠키 사용 시, 자바스크립트가 토큰을 넣어줄 필요가 없음
        // 쿠키는 브라우저가 자동으로 전송합니다.
        return config;
      },
      async (error) => {
        // 요청이 에러로 시작되면 (예외적인 케이스)
        loadingStore.stopLoading();

        // if (error.code === "ERR_BAD_REQUEST") {
        //   toast.error("서버 요청에 실패했습니다");
        //   await delay(1000);
        // }

        toast.error("에러 발생 : " + error);
        // 1초 동안 대기 (1000ms) : toast 팝업 표시
        await delay(1000);

        /**
         * 
         * 공통 에러 처리 추가하기
         * 
         */
        return Promise.reject(error.response);
      }
    );

    // ─────────────────────────────────────────────────────────────
    // (2) Response Interceptor: 응답 데이터만 반환
    // ─────────────────────────────────────────────────────────────
    apiInstance.interceptors.response.use(
      (response) => {
        // 응답이 정상적으로 왔을 때 로딩 카운트를 내림
        loadingStore.stopLoading();
        // response의 내부 데이터만 반환
        // return response.data; // 상태값 추출을 못함
        return response;
      },
      async (error) => {

        // 응답이 에러일 경우에도 로딩 카운트를 내림
        loadingStore.stopLoading();
        
        // ✅ 실패한 마이크로서비스 추출
        const url = error?.config?.baseURL || '';
        let serviceName = "Unknown Service";

        if (url.includes('/hrm')) serviceName = "HRM";
        else if (url.includes('/auth')) serviceName = "AUTH";
        else if (url.includes('/receipt')) serviceName = "RECEIPT";
        // else if (url.endsWith(':8080/') || url === 'http://localhost:8080/') serviceName = "GATEWAY";

        // 로그인 페이지 제외 401 에러시
        // if (error.response?.data?.status || error.response?.status) {
        //   if ((error.response.data.status === 401 || error.response.status === 401)
        //     && router.currentRoute.value.path !== '/') {
        //     toast.error("로그아웃 되었습니다 재로그인 해주세요");
        //     await delay(1000);
        //     authStore.logout();
        //     router.push('/');
        //   }
        // }

        /* 2) HTTP Status 분기 */
        const status   = error.response?.status;
        const errData  = error.response?.data || {};
        // const errCode  = errData.code || '';
        const errMsg   = errData.message || errData.error || '알 수 없는 오류가 발생했습니다';
        const reason = error.response?.headers['x-reason'];
        
        if (status === 401 && reason === 'ROLE_CHANGED') { // 권한 변경
          pushToastOnce('권한이 변경되었습니다\n다시 로그인해주세요');
          await delay(1500);
          authStore.logout();
          router.push('/');
        }
        else if (status === 401 && router.currentRoute.value.path !== '/') {
          pushToastOnce("로그아웃 되었습니다\n다시 로그인해주세요");
          await delay(1500);
          authStore.logout();
          // router.push('/login?error=로그아웃 되었습니다. 재로그인 해주세요');
          router.push('/');
        }
        else if (status === 403) {
          pushToastOnce(`[${serviceName}] ${errMsg}`);
          await delay(1500);
        }
        else if (
          error.code === "ERR_NETWORK" || 
          (error.code === "ERR_BAD_REQUEST" && !error.response?.data?.message)
        ) {
          pushToastOnce(`[${serviceName}] 서비스와의 연결에 실패했습니다`);
          await delay(1500);
        }
        // BACKEND  GlobalExceptionHandler에서 처리
        else {
          // 일반적인 서비스 오류 처리
          pushToastOnce(`[${serviceName}] ${errMsg}`);
          await delay(1500);
        }

        // 여기서 unresolved Promise를 반환하면
        // 이 Promise는 절대 resolve되지 않으므로 후속 then 체인이 실행되지 않음
        return new Promise(() => {});
      }
    );
  };
  
  addAuthInterceptor(systemApi);
  addAuthInterceptor(hrmApi);
  addAuthInterceptor(receiptApi);
  addAuthInterceptor(authApi);
}

export { systemApi, hrmApi, receiptApi, authApi };
