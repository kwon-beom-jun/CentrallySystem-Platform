# 파일 업로드 및 다운로드 가이드

## 목차
1. [Nginx 설정](#1-nginx-설정)
2. [프로퍼티 설정](#2-프로퍼티-설정)
3. [다운로드 제한 방법](#3-다운로드-제한-방법)
4. [다운로드 캐싱 처리](#4-다운로드-캐싱-처리)
5. [추후 Redis 적용 시 수정 사항](#5-추후-redis-적용-시-수정-사항)

---

## 1. Nginx 설정

### 1.1 파일 업로드 크기 제한

```nginx
# /etc/nginx/nginx.conf 또는 /etc/nginx/sites-available/vue-app

http {
    # 클라이언트 요청 본문 최대 크기 (업로드 파일 크기 제한)
    client_max_body_size 20m;
    
    # 클라이언트 요청 본문 버퍼 크기
    client_body_buffer_size 128k;
    
    # ...
}
```

**설명:**
- `client_max_body_size`: 단일 요청의 최대 본문 크기 (파일 업로드 포함)
- `client_body_buffer_size`: 요청 본문을 읽기 위한 버퍼 크기
- 현재 설정: **20MB** (Spring Boot 프로퍼티와 일치)

**참고:**
- 다운로드 용량 제한은 백엔드(Spring Boot)에서 처리됩니다.
- Nginx는 파일 업로드 크기 제한만 담당합니다.

---

## 2. 프로퍼티 설정

### 2.1 INFO 서비스 (`info.properties`)

```properties
# -----------------------------------------------------------------
# 파일 설정
# -----------------------------------------------------------------

# 공지사항 파일 업로드 경로 (상대 경로)
info.file.upload.url=/upload/info
# 공지사항 파일 업로드 위치
info.file.upload.path=${file.upload.path}/info

# Spring Multipart 설정
spring.servlet.multipart.enabled=true
# 단일 파일 최대 크기
spring.servlet.multipart.max-file-size=20MB
# 전체 요청의 최대 크기
spring.servlet.multipart.max-request-size=20MB
# 한번에 파일 업로드 가능 수량
file.upload.total.size=20

# 다운로드 용량 제한 (일일 제한)
download.quota.daily.limit.mb=50
```

### 2.2 RECEIPT 서비스 (`receipt.properties`)

```properties
# -----------------------------------------------------------------
# 파일 설정
# -----------------------------------------------------------------

# 영수증 파일 업로드 경로 (상대 경로)
receipt.file.upload.url=/upload/receipt
# 영수증 파일 업로드 위치
receipt.file.upload.path=${file.upload.path}/receipt

# Spring Multipart 설정
spring.servlet.multipart.enabled=true
# 단일 파일 최대 크기
spring.servlet.multipart.max-file-size=20MB
# 전체 요청의 최대 크기
spring.servlet.multipart.max-request-size=20MB
# 한번에 파일 업로드 가능 수량
file.upload.total.size=20

# 다운로드 용량 제한 (일일 제한, 영수증은 작은 파일이므로 낮게 설정)
download.quota.daily.limit.mb=20
```

### 2.3 HRM 서비스 (`hrm.properties`)

```properties
# -----------------------------------------------------------------
# 파일 설정
# -----------------------------------------------------------------

# 유저들 기본 프로필 이미지
hrm.default.profile.img=/img/profile/random/001~018.png
# 프로필 이미지 파일 업로드 경로 (상대 경로)
hrm.profile.upload.url=/upload/hrm/profile
# 프로필 이미지 파일 업로드 위치
hrm.profile.upload.path=${file.upload.path}/profile

# Spring Multipart 설정
spring.servlet.multipart.enabled=true
# 단일 파일 최대 크기
spring.servlet.multipart.max-file-size=20MB
# 전체 요청의 최대 크기
spring.servlet.multipart.max-request-size=20MB
# 한번에 파일 업로드 가능 수량
file.upload.total.size=20

# 다운로드 용량 제한 (일일 제한, 프로필 이미지는 작으므로 낮게 설정)
download.quota.daily.limit.mb=20
```

### 2.4 프로퍼티 설명

| 프로퍼티 | 설명 | 기본값 |
|---------|------|--------|
| `spring.servlet.multipart.max-file-size` | 단일 파일 최대 크기 | 20MB |
| `spring.servlet.multipart.max-request-size` | 전체 요청(파일 포함) 최대 크기 | 20MB |
| `file.upload.total.size` | 한 번에 업로드 가능한 파일 개수 | 20 |
| `download.quota.daily.limit.mb` | 일일 다운로드 용량 제한 (MB) | 서비스별 상이 |

---

## 3. 다운로드 제한 방법

### 3.1 구현 방식

현재는 **인메모리 방식**으로 구현되어 있습니다.

**구현 위치:**
- 인터페이스: `centrally-system-core/src/main/java/com/cs/core/service/DownloadQuotaService.java`
- 구현체: `centrally-system-core/src/main/java/com/cs/core/service/impl/InMemoryDownloadQuotaService.java`

**법적 고려사항:**
- IP 주소는 개인정보보호법상 개인정보로 간주될 수 있어, **사용자 ID 기반**으로 제한을 적용합니다.
- 인증된 사용자의 ID를 사용하므로 개인정보 처리에 대한 법적 리스크를 최소화합니다.

### 3.2 동작 원리

1. **용량 추적**
   - 키 형식: `"날짜:userId"` (예: `"2025-01-15:123"`)
   - 값: 다운로드한 총 바이트 수
   - `ConcurrentHashMap`으로 저장
   - **법적 고려사항**: IP 주소 대신 사용자 ID를 사용하여 개인정보보호법 준수

2. **제한 확인**
   - 다운로드 전 현재 용량 + 파일 크기 확인
   - 제한 초과 시 `RuntimeException` 발생
   - 제한 내이면 용량 증가 후 다운로드 진행

3. **자동 정리**
   - 매일 자정(`@Scheduled(cron = "0 0 0 * * ?")`)에 전날 데이터 삭제
   - 메모리 절약을 위한 자동 정리

### 3.3 적용 위치

다운로드 제한은 다음 컨트롤러에 적용됩니다:

1. **INFO 서비스**: `InfoPostFileController.java`
   ```java
   @GetMapping("/upload/info/{boardPath}/{encodedSafeName:.+}")
   ```

2. **RECEIPT 서비스**: `ReceiptFileController.java`
   ```java
   @GetMapping("/upload/receipt/{encodedSafeName:.+}")
   ```

3. **HRM 서비스**: `HrmFileController.java`
   ```java
   @GetMapping("/upload/hrm/profile/{encodedFileName:.+}")
   ```

### 3.4 제한 초과 시 동작

- **백엔드**: `RuntimeException` 발생
- **프론트엔드**: Axios 인터셉터가 500 에러를 감지하여 토스트 메시지 표시
- **에러 메시지**: `"일일 다운로드 용량 제한을 초과했습니다. (제한: {제한값}MB, 현재: {현재값}MB)"`

---

## 4. 다운로드 캐싱 처리

### 4.1 HTTP 캐싱 메커니즘

다운로드 컨트롤러에서 HTTP 캐싱을 통해 불필요한 데이터 전송을 방지합니다.

**적용 기술:**
- **ETag**: 파일 크기와 수정 시간 기반 고유 식별자
- **Last-Modified**: 파일 마지막 수정 시간
- **Cache-Control**: 캐시 유지 기간 설정
- **304 Not Modified**: 파일이 변경되지 않았을 때 빈 응답 반환

### 4.2 캐시 유지 기간

서비스별로 다른 캐시 유지 기간이 설정되어 있습니다:

| 서비스 | 캐시 기간 | 위치 |
|--------|----------|------|
| INFO | 1일 | `InfoPostFileController.CACHE_MAX_AGE_DAYS = 1L` |
| RECEIPT | 1일 | `ReceiptFileController.CACHE_MAX_AGE_DAYS = 1L` |
| HRM | 7일 | `HrmFileController.CACHE_MAX_AGE_DAYS = 7L` |

**설정 이유:**
- INFO/RECEIPT: 파일 변경 가능성이 높아 짧은 캐시 기간
- HRM: 프로필 이미지는 변경 빈도가 낮아 긴 캐시 기간

### 4.3 동작 흐름

```
1. 클라이언트 요청 (If-None-Match, If-Modified-Since 헤더 포함)
   ↓
2. 서버에서 ETag 및 Last-Modified 생성
   - ETag: "파일크기-수정시간"
   - Last-Modified: 파일의 lastModified() 값
   ↓
3. Spring의 WebRequest.checkNotModified() 호출
   ↓
4. 파일 변경 여부 확인
   ├─ 변경 없음 → 304 Not Modified 반환 (용량 제한 제외)
   └─ 변경 있음 → 200 OK + 파일 데이터 반환 (용량 제한 적용)
```

### 4.4 구현 코드 예시

```java
// 캐싱 처리
long fileSize = stored.length();
long lastModified = stored.lastModified();
Instant lastModifiedInstant = Instant.ofEpochMilli(lastModified);
String etag = "\"" + fileSize + "-" + lastModified + "\"";

// Spring이 자동으로 304 처리 (ETag + Last-Modified 기반)
if (webRequest.checkNotModified(etag, lastModified)) {
    // 파일이 변경되지 않음 → 304 Not Modified 반환 (용량 제한 제외)
    return null; // Spring이 자동으로 304 응답 처리
}

// 다운로드 용량 제한 확인 (304 응답이 아닐 때만)
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
if (auth != null && auth.getPrincipal() instanceof CustomUserPrincipal principal) {
    Integer userId = principal.getUserId();
    downloadQuotaService.checkAndIncrementDownloadSize(userId, fileSize);
}

// 응답 헤더 설정
return ResponseEntity.ok()
        .lastModified(lastModifiedInstant)
        .eTag(etag)
        .cacheControl(CacheControl.maxAge(CACHE_MAX_AGE_DAYS, TimeUnit.DAYS))
        .header(HttpHeaders.CONTENT_DISPOSITION, disposition)
        .contentType(media)
        .body(new FileSystemResource(stored));
```

### 4.5 캐싱 효과

- **304 응답**: 파일이 변경되지 않았을 때 빈 응답 반환 (용량 제한 제외)
- **대역폭 절약**: 동일 파일 재요청 시 실제 데이터 전송 없음
- **서버 부하 감소**: 파일 I/O 및 네트워크 전송 최소화

---

## 5. 추후 Redis 적용 시 수정 사항

### 5.1 현재 구조

현재는 `DownloadQuotaService` 인터페이스를 통해 구현체를 쉽게 교체할 수 있도록 설계되어 있습니다.

**인터페이스:**
```java
public interface DownloadQuotaService {
    void checkAndIncrementDownloadSize(Integer userId, long fileSize);
    long getCurrentDownloadSizeMB(Integer userId);
}
```

**현재 구현체:**
- `InMemoryDownloadQuotaService`: `ConcurrentHashMap` 사용

### 5.2 Redis 구현체 생성

**새 파일 생성:**
```
centrally-system-core/src/main/java/com/cs/core/service/impl/RedisDownloadQuotaService.java
```

**구현 예시:**
```java
@Service("downloadQuotaService")
@ConditionalOnProperty(name = "download.quota.type", havingValue = "redis")
public class RedisDownloadQuotaService implements DownloadQuotaService {
    
    private final RedisTemplate<String, Long> redisTemplate;
    
    @Value("${download.quota.daily.limit.mb:1000}")
    private long dailyLimitMB;
    
    private long dailyLimitBytes;
    
    @PostConstruct
    void init() {
        dailyLimitBytes = dailyLimitMB * 1024 * 1024;
    }
    
    @Override
    public void checkAndIncrementDownloadSize(Integer userId, long fileSize) {
        if (userId == null) {
            throw new IllegalArgumentException("사용자 ID가 필요합니다.");
        }
        
        String key = getTodayKey(userId);
        
        // Redis에서 현재 용량 조회
        Long currentSize = redisTemplate.opsForValue().get(key);
        if (currentSize == null) {
            currentSize = 0L;
        }
        
        // 제한 초과 확인
        if (currentSize + fileSize > dailyLimitBytes) {
            long currentMB = currentSize / 1024 / 1024;
            throw new RuntimeException(
                GlobalExceptionHandler.CC + 
                String.format("일일 다운로드 용량 제한을 초과했습니다. (제한: %dMB, 현재: %dMB)", 
                    dailyLimitMB, currentMB)
            );
        }
        
        // 용량 증가 (TTL 설정: 다음날 자정까지)
        long ttl = getSecondsUntilMidnight();
        redisTemplate.opsForValue().set(key, currentSize + fileSize, ttl, TimeUnit.SECONDS);
    }
    
    @Override
    public long getCurrentDownloadSizeMB(Integer userId) {
        if (userId == null) {
            return 0L;
        }
        String key = getTodayKey(userId);
        Long bytes = redisTemplate.opsForValue().get(key);
        if (bytes == null) {
            return 0L;
        }
        return bytes / 1024 / 1024;
    }
    
    private String getTodayKey(Integer userId) {
        return "download:quota:" + LocalDate.now().toString() + ":" + userId;
    }
    
    private long getSecondsUntilMidnight() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime midnight = now.toLocalDate().plusDays(1).atStartOfDay();
        return ChronoUnit.SECONDS.between(now, midnight);
    }
}
```

### 5.3 프로퍼티 설정 추가

**각 서비스 프로퍼티 파일에 추가:**
```properties
# 다운로드 용량 제한 구현 방식 (memory 또는 redis)
download.quota.type=memory
# 또는
download.quota.type=redis

# Redis 설정 (Redis 사용 시)
spring.data.redis.host=your-redis-host
spring.data.redis.port=6379
spring.data.redis.password=your-redis-password
```

### 5.4 의존성 추가

**`centrally-system-core/pom.xml`에 추가:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

### 5.5 Bean 선택 로직

**현재:**
- `@Service("downloadQuotaService")`로 단일 구현체만 활성화

**Redis 적용 시:**
- `@ConditionalOnProperty`를 사용하여 프로퍼티에 따라 구현체 선택
- 또는 `@Primary` 어노테이션으로 우선순위 지정

### 5.6 Redis 적용 시 장점

1. **분산 환경 지원**: 여러 서버 인스턴스 간 공유 가능
2. **영속성**: 서버 재시작 시에도 데이터 유지 (TTL 설정 시 자동 만료)
3. **확장성**: 대용량 트래픽 처리 가능
4. **자동 정리**: TTL로 자동 만료 처리 (스케줄러 불필요)

### 5.7 마이그레이션 체크리스트

- [ ] Redis 서버 설치 및 설정
- [ ] `RedisDownloadQuotaService` 구현체 생성
- [ ] 프로퍼티에 `download.quota.type=redis` 설정
- [ ] Redis 의존성 추가 (`pom.xml`)
- [ ] Redis 연결 설정 (`application.properties`)
- [ ] 기존 인메모리 구현체 비활성화 또는 제거
- [ ] 테스트 환경에서 검증
- [ ] 운영 환경 배포

---

## 부록

### A. 파일 저장 경로 구조

```
${file.upload.path}/
├── info/
│   ├── notice/          # 공지사항 게시판
│   ├── resource/        # 자료실 게시판
│   └── community/       # 커뮤니티 게시판
├── receipt/             # 영수증 첨부파일
└── profile/             # 프로필 이미지
```

### B. 에러 코드

| 에러 | 원인 | 해결 방법 |
|------|------|----------|
| `413 Request Entity Too Large` | 업로드 파일 크기 초과 | Nginx `client_max_body_size` 또는 Spring `max-file-size` 증가 |
| `일일 다운로드 용량 제한 초과` | 다운로드 용량 초과 | 다음날까지 대기 또는 제한 값 증가 |

### C. 모니터링 권장 사항

1. **다운로드 용량 모니터링**
   - 일일 다운로드 용량 통계
   - 다운로드 패턴 분석

2. **캐시 히트율 모니터링**
   - 304 응답 비율 확인
   - 캐시 효과 측정

3. **에러 모니터링**
   - 413 에러 발생 빈도 (업로드 크기 초과)
   - 다운로드 제한 초과 빈도

---

**작성일**: YYYY-MM-DD  
**최종 수정일**: YYYY-MM-DD

